// source: eth.proto
/**
 * @fileoverview
 * @enhanceable
 * @suppress {missingRequire} reports error on implicit type usages.
 * @suppress {messageConventions} JS Compiler reports an error if a variable or
 *     field starts with 'MSG_' and isn't a translatable message.
 * @public
 */
// GENERATED CODE -- DO NOT EDIT!
/* eslint-disable */
// @ts-nocheck

var jspb = require('google-protobuf');
var goog = jspb;
var global = Function('return this')();

var google_protobuf_empty_pb = require('google-protobuf/google/protobuf/empty_pb.js');
goog.object.extend(proto, google_protobuf_empty_pb);
var types_pb = require('./types_pb.js');
goog.object.extend(proto, types_pb);
goog.exportSymbol('proto.eth.AccessListItem', null, global);
goog.exportSymbol('proto.eth.AccessTuple', null, global);
goog.exportSymbol('proto.eth.Block', null, global);
goog.exportSymbol('proto.eth.BlockId', null, global);
goog.exportSymbol('proto.eth.BlockId.IdCase', null, global);
goog.exportSymbol('proto.eth.BlockNumber', null, global);
goog.exportSymbol('proto.eth.BlockNumber.BlockNumberCase', null, global);
goog.exportSymbol('proto.eth.Body', null, global);
goog.exportSymbol('proto.eth.CanonicalTransactionData', null, global);
goog.exportSymbol('proto.eth.Header', null, global);
goog.exportSymbol('proto.eth.StoredTransaction', null, global);
goog.exportSymbol('proto.eth.Transaction', null, global);
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.eth.BlockNumber = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, proto.eth.BlockNumber.oneofGroups_);
};
goog.inherits(proto.eth.BlockNumber, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.eth.BlockNumber.displayName = 'proto.eth.BlockNumber';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.eth.BlockId = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, proto.eth.BlockId.oneofGroups_);
};
goog.inherits(proto.eth.BlockId, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.eth.BlockId.displayName = 'proto.eth.BlockId';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.eth.CanonicalTransactionData = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.eth.CanonicalTransactionData, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.eth.CanonicalTransactionData.displayName = 'proto.eth.CanonicalTransactionData';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.eth.AccessListItem = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.eth.AccessListItem.repeatedFields_, null);
};
goog.inherits(proto.eth.AccessListItem, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.eth.AccessListItem.displayName = 'proto.eth.AccessListItem';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.eth.Transaction = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.eth.Transaction.repeatedFields_, null);
};
goog.inherits(proto.eth.Transaction, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.eth.Transaction.displayName = 'proto.eth.Transaction';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.eth.AccessTuple = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.eth.AccessTuple.repeatedFields_, null);
};
goog.inherits(proto.eth.AccessTuple, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.eth.AccessTuple.displayName = 'proto.eth.AccessTuple';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.eth.StoredTransaction = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.eth.StoredTransaction, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.eth.StoredTransaction.displayName = 'proto.eth.StoredTransaction';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.eth.Header = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.eth.Header, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.eth.Header.displayName = 'proto.eth.Header';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.eth.Body = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.eth.Body.repeatedFields_, null);
};
goog.inherits(proto.eth.Body, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.eth.Body.displayName = 'proto.eth.Body';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.eth.Block = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.eth.Block, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.eth.Block.displayName = 'proto.eth.Block';
}

/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.eth.BlockNumber.oneofGroups_ = [[1,2,3]];

/**
 * @enum {number}
 */
proto.eth.BlockNumber.BlockNumberCase = {
  BLOCK_NUMBER_NOT_SET: 0,
  LATEST: 1,
  PENDING: 2,
  NUMBER: 3
};

/**
 * @return {proto.eth.BlockNumber.BlockNumberCase}
 */
proto.eth.BlockNumber.prototype.getBlockNumberCase = function() {
  return /** @type {proto.eth.BlockNumber.BlockNumberCase} */(jspb.Message.computeOneofCase(this, proto.eth.BlockNumber.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.eth.BlockNumber.prototype.toObject = function(opt_includeInstance) {
  return proto.eth.BlockNumber.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.eth.BlockNumber} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.eth.BlockNumber.toObject = function(includeInstance, msg) {
  var f, obj = {
    latest: (f = msg.getLatest()) && google_protobuf_empty_pb.Empty.toObject(includeInstance, f),
    pending: (f = msg.getPending()) && google_protobuf_empty_pb.Empty.toObject(includeInstance, f),
    number: jspb.Message.getFieldWithDefault(msg, 3, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.eth.BlockNumber}
 */
proto.eth.BlockNumber.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.eth.BlockNumber;
  return proto.eth.BlockNumber.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.eth.BlockNumber} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.eth.BlockNumber}
 */
proto.eth.BlockNumber.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new google_protobuf_empty_pb.Empty;
      reader.readMessage(value,google_protobuf_empty_pb.Empty.deserializeBinaryFromReader);
      msg.setLatest(value);
      break;
    case 2:
      var value = new google_protobuf_empty_pb.Empty;
      reader.readMessage(value,google_protobuf_empty_pb.Empty.deserializeBinaryFromReader);
      msg.setPending(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setNumber(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.eth.BlockNumber.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.eth.BlockNumber.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.eth.BlockNumber} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.eth.BlockNumber.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getLatest();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      google_protobuf_empty_pb.Empty.serializeBinaryToWriter
    );
  }
  f = message.getPending();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      google_protobuf_empty_pb.Empty.serializeBinaryToWriter
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeUint64(
      3,
      f
    );
  }
};


/**
 * optional google.protobuf.Empty latest = 1;
 * @return {?proto.google.protobuf.Empty}
 */
proto.eth.BlockNumber.prototype.getLatest = function() {
  return /** @type{?proto.google.protobuf.Empty} */ (
    jspb.Message.getWrapperField(this, google_protobuf_empty_pb.Empty, 1));
};


/**
 * @param {?proto.google.protobuf.Empty|undefined} value
 * @return {!proto.eth.BlockNumber} returns this
*/
proto.eth.BlockNumber.prototype.setLatest = function(value) {
  return jspb.Message.setOneofWrapperField(this, 1, proto.eth.BlockNumber.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.eth.BlockNumber} returns this
 */
proto.eth.BlockNumber.prototype.clearLatest = function() {
  return this.setLatest(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.eth.BlockNumber.prototype.hasLatest = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional google.protobuf.Empty pending = 2;
 * @return {?proto.google.protobuf.Empty}
 */
proto.eth.BlockNumber.prototype.getPending = function() {
  return /** @type{?proto.google.protobuf.Empty} */ (
    jspb.Message.getWrapperField(this, google_protobuf_empty_pb.Empty, 2));
};


/**
 * @param {?proto.google.protobuf.Empty|undefined} value
 * @return {!proto.eth.BlockNumber} returns this
*/
proto.eth.BlockNumber.prototype.setPending = function(value) {
  return jspb.Message.setOneofWrapperField(this, 2, proto.eth.BlockNumber.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.eth.BlockNumber} returns this
 */
proto.eth.BlockNumber.prototype.clearPending = function() {
  return this.setPending(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.eth.BlockNumber.prototype.hasPending = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional uint64 number = 3;
 * @return {number}
 */
proto.eth.BlockNumber.prototype.getNumber = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/**
 * @param {number} value
 * @return {!proto.eth.BlockNumber} returns this
 */
proto.eth.BlockNumber.prototype.setNumber = function(value) {
  return jspb.Message.setOneofField(this, 3, proto.eth.BlockNumber.oneofGroups_[0], value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.eth.BlockNumber} returns this
 */
proto.eth.BlockNumber.prototype.clearNumber = function() {
  return jspb.Message.setOneofField(this, 3, proto.eth.BlockNumber.oneofGroups_[0], undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.eth.BlockNumber.prototype.hasNumber = function() {
  return jspb.Message.getField(this, 3) != null;
};



/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.eth.BlockId.oneofGroups_ = [[1,2]];

/**
 * @enum {number}
 */
proto.eth.BlockId.IdCase = {
  ID_NOT_SET: 0,
  HASH: 1,
  NUMBER: 2
};

/**
 * @return {proto.eth.BlockId.IdCase}
 */
proto.eth.BlockId.prototype.getIdCase = function() {
  return /** @type {proto.eth.BlockId.IdCase} */(jspb.Message.computeOneofCase(this, proto.eth.BlockId.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.eth.BlockId.prototype.toObject = function(opt_includeInstance) {
  return proto.eth.BlockId.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.eth.BlockId} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.eth.BlockId.toObject = function(includeInstance, msg) {
  var f, obj = {
    hash: (f = msg.getHash()) && types_pb.H256.toObject(includeInstance, f),
    number: (f = msg.getNumber()) && proto.eth.BlockNumber.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.eth.BlockId}
 */
proto.eth.BlockId.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.eth.BlockId;
  return proto.eth.BlockId.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.eth.BlockId} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.eth.BlockId}
 */
proto.eth.BlockId.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new types_pb.H256;
      reader.readMessage(value,types_pb.H256.deserializeBinaryFromReader);
      msg.setHash(value);
      break;
    case 2:
      var value = new proto.eth.BlockNumber;
      reader.readMessage(value,proto.eth.BlockNumber.deserializeBinaryFromReader);
      msg.setNumber(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.eth.BlockId.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.eth.BlockId.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.eth.BlockId} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.eth.BlockId.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getHash();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      types_pb.H256.serializeBinaryToWriter
    );
  }
  f = message.getNumber();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.eth.BlockNumber.serializeBinaryToWriter
    );
  }
};


/**
 * optional types.H256 hash = 1;
 * @return {?proto.types.H256}
 */
proto.eth.BlockId.prototype.getHash = function() {
  return /** @type{?proto.types.H256} */ (
    jspb.Message.getWrapperField(this, types_pb.H256, 1));
};


/**
 * @param {?proto.types.H256|undefined} value
 * @return {!proto.eth.BlockId} returns this
*/
proto.eth.BlockId.prototype.setHash = function(value) {
  return jspb.Message.setOneofWrapperField(this, 1, proto.eth.BlockId.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.eth.BlockId} returns this
 */
proto.eth.BlockId.prototype.clearHash = function() {
  return this.setHash(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.eth.BlockId.prototype.hasHash = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional BlockNumber number = 2;
 * @return {?proto.eth.BlockNumber}
 */
proto.eth.BlockId.prototype.getNumber = function() {
  return /** @type{?proto.eth.BlockNumber} */ (
    jspb.Message.getWrapperField(this, proto.eth.BlockNumber, 2));
};


/**
 * @param {?proto.eth.BlockNumber|undefined} value
 * @return {!proto.eth.BlockId} returns this
*/
proto.eth.BlockId.prototype.setNumber = function(value) {
  return jspb.Message.setOneofWrapperField(this, 2, proto.eth.BlockId.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.eth.BlockId} returns this
 */
proto.eth.BlockId.prototype.clearNumber = function() {
  return this.setNumber(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.eth.BlockId.prototype.hasNumber = function() {
  return jspb.Message.getField(this, 2) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.eth.CanonicalTransactionData.prototype.toObject = function(opt_includeInstance) {
  return proto.eth.CanonicalTransactionData.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.eth.CanonicalTransactionData} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.eth.CanonicalTransactionData.toObject = function(includeInstance, msg) {
  var f, obj = {
    blockHash: (f = msg.getBlockHash()) && types_pb.H256.toObject(includeInstance, f),
    blockNumber: jspb.Message.getFieldWithDefault(msg, 2, 0),
    index: jspb.Message.getFieldWithDefault(msg, 3, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.eth.CanonicalTransactionData}
 */
proto.eth.CanonicalTransactionData.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.eth.CanonicalTransactionData;
  return proto.eth.CanonicalTransactionData.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.eth.CanonicalTransactionData} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.eth.CanonicalTransactionData}
 */
proto.eth.CanonicalTransactionData.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new types_pb.H256;
      reader.readMessage(value,types_pb.H256.deserializeBinaryFromReader);
      msg.setBlockHash(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setBlockNumber(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setIndex(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.eth.CanonicalTransactionData.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.eth.CanonicalTransactionData.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.eth.CanonicalTransactionData} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.eth.CanonicalTransactionData.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getBlockHash();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      types_pb.H256.serializeBinaryToWriter
    );
  }
  f = message.getBlockNumber();
  if (f !== 0) {
    writer.writeUint64(
      2,
      f
    );
  }
  f = message.getIndex();
  if (f !== 0) {
    writer.writeUint64(
      3,
      f
    );
  }
};


/**
 * optional types.H256 block_hash = 1;
 * @return {?proto.types.H256}
 */
proto.eth.CanonicalTransactionData.prototype.getBlockHash = function() {
  return /** @type{?proto.types.H256} */ (
    jspb.Message.getWrapperField(this, types_pb.H256, 1));
};


/**
 * @param {?proto.types.H256|undefined} value
 * @return {!proto.eth.CanonicalTransactionData} returns this
*/
proto.eth.CanonicalTransactionData.prototype.setBlockHash = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.eth.CanonicalTransactionData} returns this
 */
proto.eth.CanonicalTransactionData.prototype.clearBlockHash = function() {
  return this.setBlockHash(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.eth.CanonicalTransactionData.prototype.hasBlockHash = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional uint64 block_number = 2;
 * @return {number}
 */
proto.eth.CanonicalTransactionData.prototype.getBlockNumber = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {number} value
 * @return {!proto.eth.CanonicalTransactionData} returns this
 */
proto.eth.CanonicalTransactionData.prototype.setBlockNumber = function(value) {
  return jspb.Message.setProto3IntField(this, 2, value);
};


/**
 * optional uint64 index = 3;
 * @return {number}
 */
proto.eth.CanonicalTransactionData.prototype.getIndex = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/**
 * @param {number} value
 * @return {!proto.eth.CanonicalTransactionData} returns this
 */
proto.eth.CanonicalTransactionData.prototype.setIndex = function(value) {
  return jspb.Message.setProto3IntField(this, 3, value);
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.eth.AccessListItem.repeatedFields_ = [2];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.eth.AccessListItem.prototype.toObject = function(opt_includeInstance) {
  return proto.eth.AccessListItem.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.eth.AccessListItem} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.eth.AccessListItem.toObject = function(includeInstance, msg) {
  var f, obj = {
    address: (f = msg.getAddress()) && types_pb.H160.toObject(includeInstance, f),
    slotsList: jspb.Message.toObjectList(msg.getSlotsList(),
    types_pb.H256.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.eth.AccessListItem}
 */
proto.eth.AccessListItem.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.eth.AccessListItem;
  return proto.eth.AccessListItem.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.eth.AccessListItem} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.eth.AccessListItem}
 */
proto.eth.AccessListItem.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new types_pb.H160;
      reader.readMessage(value,types_pb.H160.deserializeBinaryFromReader);
      msg.setAddress(value);
      break;
    case 2:
      var value = new types_pb.H256;
      reader.readMessage(value,types_pb.H256.deserializeBinaryFromReader);
      msg.addSlots(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.eth.AccessListItem.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.eth.AccessListItem.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.eth.AccessListItem} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.eth.AccessListItem.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAddress();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      types_pb.H160.serializeBinaryToWriter
    );
  }
  f = message.getSlotsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      2,
      f,
      types_pb.H256.serializeBinaryToWriter
    );
  }
};


/**
 * optional types.H160 address = 1;
 * @return {?proto.types.H160}
 */
proto.eth.AccessListItem.prototype.getAddress = function() {
  return /** @type{?proto.types.H160} */ (
    jspb.Message.getWrapperField(this, types_pb.H160, 1));
};


/**
 * @param {?proto.types.H160|undefined} value
 * @return {!proto.eth.AccessListItem} returns this
*/
proto.eth.AccessListItem.prototype.setAddress = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.eth.AccessListItem} returns this
 */
proto.eth.AccessListItem.prototype.clearAddress = function() {
  return this.setAddress(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.eth.AccessListItem.prototype.hasAddress = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * repeated types.H256 slots = 2;
 * @return {!Array<!proto.types.H256>}
 */
proto.eth.AccessListItem.prototype.getSlotsList = function() {
  return /** @type{!Array<!proto.types.H256>} */ (
    jspb.Message.getRepeatedWrapperField(this, types_pb.H256, 2));
};


/**
 * @param {!Array<!proto.types.H256>} value
 * @return {!proto.eth.AccessListItem} returns this
*/
proto.eth.AccessListItem.prototype.setSlotsList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 2, value);
};


/**
 * @param {!proto.types.H256=} opt_value
 * @param {number=} opt_index
 * @return {!proto.types.H256}
 */
proto.eth.AccessListItem.prototype.addSlots = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 2, opt_value, proto.types.H256, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.eth.AccessListItem} returns this
 */
proto.eth.AccessListItem.prototype.clearSlotsList = function() {
  return this.setSlotsList([]);
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.eth.Transaction.repeatedFields_ = [16];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.eth.Transaction.prototype.toObject = function(opt_includeInstance) {
  return proto.eth.Transaction.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.eth.Transaction} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.eth.Transaction.toObject = function(includeInstance, msg) {
  var f, obj = {
    to: msg.getTo_asB64(),
    gas: jspb.Message.getFieldWithDefault(msg, 2, 0),
    gasPrice: jspb.Message.getFieldWithDefault(msg, 3, 0),
    hash: msg.getHash_asB64(),
    input: msg.getInput_asB64(),
    nonce: jspb.Message.getFieldWithDefault(msg, 6, 0),
    value: msg.getValue_asB64(),
    from: msg.getFrom_asB64(),
    type: jspb.Message.getFieldWithDefault(msg, 9, 0),
    maxFee: jspb.Message.getFieldWithDefault(msg, 10, 0),
    priorityFee: jspb.Message.getFieldWithDefault(msg, 11, 0),
    v: jspb.Message.getFieldWithDefault(msg, 12, 0),
    r: msg.getR_asB64(),
    s: msg.getS_asB64(),
    chainid: jspb.Message.getFieldWithDefault(msg, 15, 0),
    accessListList: jspb.Message.toObjectList(msg.getAccessListList(),
    proto.eth.AccessTuple.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.eth.Transaction}
 */
proto.eth.Transaction.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.eth.Transaction;
  return proto.eth.Transaction.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.eth.Transaction} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.eth.Transaction}
 */
proto.eth.Transaction.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setTo(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setGas(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setGasPrice(value);
      break;
    case 4:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setHash(value);
      break;
    case 5:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setInput(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setNonce(value);
      break;
    case 7:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setValue(value);
      break;
    case 8:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setFrom(value);
      break;
    case 9:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setType(value);
      break;
    case 10:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setMaxFee(value);
      break;
    case 11:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setPriorityFee(value);
      break;
    case 12:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setV(value);
      break;
    case 13:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setR(value);
      break;
    case 14:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setS(value);
      break;
    case 15:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setChainid(value);
      break;
    case 16:
      var value = new proto.eth.AccessTuple;
      reader.readMessage(value,proto.eth.AccessTuple.deserializeBinaryFromReader);
      msg.addAccessList(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.eth.Transaction.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.eth.Transaction.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.eth.Transaction} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.eth.Transaction.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getGas();
  if (f !== 0) {
    writer.writeUint64(
      2,
      f
    );
  }
  f = message.getGasPrice();
  if (f !== 0) {
    writer.writeUint64(
      3,
      f
    );
  }
  f = message.getHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      4,
      f
    );
  }
  f = message.getInput_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      5,
      f
    );
  }
  f = message.getNonce();
  if (f !== 0) {
    writer.writeUint64(
      6,
      f
    );
  }
  f = message.getValue_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      7,
      f
    );
  }
  f = message.getFrom_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      8,
      f
    );
  }
  f = message.getType();
  if (f !== 0) {
    writer.writeUint32(
      9,
      f
    );
  }
  f = message.getMaxFee();
  if (f !== 0) {
    writer.writeUint64(
      10,
      f
    );
  }
  f = message.getPriorityFee();
  if (f !== 0) {
    writer.writeUint64(
      11,
      f
    );
  }
  f = message.getV();
  if (f !== 0) {
    writer.writeUint64(
      12,
      f
    );
  }
  f = message.getR_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      13,
      f
    );
  }
  f = message.getS_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      14,
      f
    );
  }
  f = message.getChainid();
  if (f !== 0) {
    writer.writeUint32(
      15,
      f
    );
  }
  f = message.getAccessListList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      16,
      f,
      proto.eth.AccessTuple.serializeBinaryToWriter
    );
  }
};


/**
 * optional bytes to = 1;
 * @return {string}
 */
proto.eth.Transaction.prototype.getTo = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes to = 1;
 * This is a type-conversion wrapper around `getTo()`
 * @return {string}
 */
proto.eth.Transaction.prototype.getTo_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getTo()));
};


/**
 * optional bytes to = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getTo()`
 * @return {!Uint8Array}
 */
proto.eth.Transaction.prototype.getTo_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getTo()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.eth.Transaction} returns this
 */
proto.eth.Transaction.prototype.setTo = function(value) {
  return jspb.Message.setField(this, 1, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.eth.Transaction} returns this
 */
proto.eth.Transaction.prototype.clearTo = function() {
  return jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.eth.Transaction.prototype.hasTo = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional uint64 gas = 2;
 * @return {number}
 */
proto.eth.Transaction.prototype.getGas = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {number} value
 * @return {!proto.eth.Transaction} returns this
 */
proto.eth.Transaction.prototype.setGas = function(value) {
  return jspb.Message.setProto3IntField(this, 2, value);
};


/**
 * optional uint64 gas_price = 3;
 * @return {number}
 */
proto.eth.Transaction.prototype.getGasPrice = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/**
 * @param {number} value
 * @return {!proto.eth.Transaction} returns this
 */
proto.eth.Transaction.prototype.setGasPrice = function(value) {
  return jspb.Message.setProto3IntField(this, 3, value);
};


/**
 * optional bytes hash = 4;
 * @return {string}
 */
proto.eth.Transaction.prototype.getHash = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/**
 * optional bytes hash = 4;
 * This is a type-conversion wrapper around `getHash()`
 * @return {string}
 */
proto.eth.Transaction.prototype.getHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getHash()));
};


/**
 * optional bytes hash = 4;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getHash()`
 * @return {!Uint8Array}
 */
proto.eth.Transaction.prototype.getHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getHash()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.eth.Transaction} returns this
 */
proto.eth.Transaction.prototype.setHash = function(value) {
  return jspb.Message.setProto3BytesField(this, 4, value);
};


/**
 * optional bytes input = 5;
 * @return {string}
 */
proto.eth.Transaction.prototype.getInput = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 5, ""));
};


/**
 * optional bytes input = 5;
 * This is a type-conversion wrapper around `getInput()`
 * @return {string}
 */
proto.eth.Transaction.prototype.getInput_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getInput()));
};


/**
 * optional bytes input = 5;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getInput()`
 * @return {!Uint8Array}
 */
proto.eth.Transaction.prototype.getInput_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getInput()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.eth.Transaction} returns this
 */
proto.eth.Transaction.prototype.setInput = function(value) {
  return jspb.Message.setProto3BytesField(this, 5, value);
};


/**
 * optional uint64 nonce = 6;
 * @return {number}
 */
proto.eth.Transaction.prototype.getNonce = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 6, 0));
};


/**
 * @param {number} value
 * @return {!proto.eth.Transaction} returns this
 */
proto.eth.Transaction.prototype.setNonce = function(value) {
  return jspb.Message.setProto3IntField(this, 6, value);
};


/**
 * optional bytes value = 7;
 * @return {string}
 */
proto.eth.Transaction.prototype.getValue = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 7, ""));
};


/**
 * optional bytes value = 7;
 * This is a type-conversion wrapper around `getValue()`
 * @return {string}
 */
proto.eth.Transaction.prototype.getValue_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getValue()));
};


/**
 * optional bytes value = 7;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getValue()`
 * @return {!Uint8Array}
 */
proto.eth.Transaction.prototype.getValue_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getValue()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.eth.Transaction} returns this
 */
proto.eth.Transaction.prototype.setValue = function(value) {
  return jspb.Message.setProto3BytesField(this, 7, value);
};


/**
 * optional bytes from = 8;
 * @return {string}
 */
proto.eth.Transaction.prototype.getFrom = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 8, ""));
};


/**
 * optional bytes from = 8;
 * This is a type-conversion wrapper around `getFrom()`
 * @return {string}
 */
proto.eth.Transaction.prototype.getFrom_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getFrom()));
};


/**
 * optional bytes from = 8;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getFrom()`
 * @return {!Uint8Array}
 */
proto.eth.Transaction.prototype.getFrom_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getFrom()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.eth.Transaction} returns this
 */
proto.eth.Transaction.prototype.setFrom = function(value) {
  return jspb.Message.setProto3BytesField(this, 8, value);
};


/**
 * optional uint32 type = 9;
 * @return {number}
 */
proto.eth.Transaction.prototype.getType = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 9, 0));
};


/**
 * @param {number} value
 * @return {!proto.eth.Transaction} returns this
 */
proto.eth.Transaction.prototype.setType = function(value) {
  return jspb.Message.setProto3IntField(this, 9, value);
};


/**
 * optional uint64 max_fee = 10;
 * @return {number}
 */
proto.eth.Transaction.prototype.getMaxFee = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 10, 0));
};


/**
 * @param {number} value
 * @return {!proto.eth.Transaction} returns this
 */
proto.eth.Transaction.prototype.setMaxFee = function(value) {
  return jspb.Message.setProto3IntField(this, 10, value);
};


/**
 * optional uint64 priority_fee = 11;
 * @return {number}
 */
proto.eth.Transaction.prototype.getPriorityFee = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 11, 0));
};


/**
 * @param {number} value
 * @return {!proto.eth.Transaction} returns this
 */
proto.eth.Transaction.prototype.setPriorityFee = function(value) {
  return jspb.Message.setProto3IntField(this, 11, value);
};


/**
 * optional uint64 v = 12;
 * @return {number}
 */
proto.eth.Transaction.prototype.getV = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 12, 0));
};


/**
 * @param {number} value
 * @return {!proto.eth.Transaction} returns this
 */
proto.eth.Transaction.prototype.setV = function(value) {
  return jspb.Message.setProto3IntField(this, 12, value);
};


/**
 * optional bytes r = 13;
 * @return {string}
 */
proto.eth.Transaction.prototype.getR = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 13, ""));
};


/**
 * optional bytes r = 13;
 * This is a type-conversion wrapper around `getR()`
 * @return {string}
 */
proto.eth.Transaction.prototype.getR_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getR()));
};


/**
 * optional bytes r = 13;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getR()`
 * @return {!Uint8Array}
 */
proto.eth.Transaction.prototype.getR_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getR()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.eth.Transaction} returns this
 */
proto.eth.Transaction.prototype.setR = function(value) {
  return jspb.Message.setProto3BytesField(this, 13, value);
};


/**
 * optional bytes s = 14;
 * @return {string}
 */
proto.eth.Transaction.prototype.getS = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 14, ""));
};


/**
 * optional bytes s = 14;
 * This is a type-conversion wrapper around `getS()`
 * @return {string}
 */
proto.eth.Transaction.prototype.getS_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getS()));
};


/**
 * optional bytes s = 14;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getS()`
 * @return {!Uint8Array}
 */
proto.eth.Transaction.prototype.getS_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getS()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.eth.Transaction} returns this
 */
proto.eth.Transaction.prototype.setS = function(value) {
  return jspb.Message.setProto3BytesField(this, 14, value);
};


/**
 * optional uint32 chainId = 15;
 * @return {number}
 */
proto.eth.Transaction.prototype.getChainid = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 15, 0));
};


/**
 * @param {number} value
 * @return {!proto.eth.Transaction} returns this
 */
proto.eth.Transaction.prototype.setChainid = function(value) {
  return jspb.Message.setProto3IntField(this, 15, value);
};


/**
 * repeated AccessTuple access_list = 16;
 * @return {!Array<!proto.eth.AccessTuple>}
 */
proto.eth.Transaction.prototype.getAccessListList = function() {
  return /** @type{!Array<!proto.eth.AccessTuple>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.eth.AccessTuple, 16));
};


/**
 * @param {!Array<!proto.eth.AccessTuple>} value
 * @return {!proto.eth.Transaction} returns this
*/
proto.eth.Transaction.prototype.setAccessListList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 16, value);
};


/**
 * @param {!proto.eth.AccessTuple=} opt_value
 * @param {number=} opt_index
 * @return {!proto.eth.AccessTuple}
 */
proto.eth.Transaction.prototype.addAccessList = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 16, opt_value, proto.eth.AccessTuple, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.eth.Transaction} returns this
 */
proto.eth.Transaction.prototype.clearAccessListList = function() {
  return this.setAccessListList([]);
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.eth.AccessTuple.repeatedFields_ = [2];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.eth.AccessTuple.prototype.toObject = function(opt_includeInstance) {
  return proto.eth.AccessTuple.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.eth.AccessTuple} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.eth.AccessTuple.toObject = function(includeInstance, msg) {
  var f, obj = {
    address: msg.getAddress_asB64(),
    storageKeysList: msg.getStorageKeysList_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.eth.AccessTuple}
 */
proto.eth.AccessTuple.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.eth.AccessTuple;
  return proto.eth.AccessTuple.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.eth.AccessTuple} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.eth.AccessTuple}
 */
proto.eth.AccessTuple.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setAddress(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.addStorageKeys(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.eth.AccessTuple.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.eth.AccessTuple.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.eth.AccessTuple} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.eth.AccessTuple.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAddress_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getStorageKeysList_asU8();
  if (f.length > 0) {
    writer.writeRepeatedBytes(
      2,
      f
    );
  }
};


/**
 * optional bytes address = 1;
 * @return {string}
 */
proto.eth.AccessTuple.prototype.getAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes address = 1;
 * This is a type-conversion wrapper around `getAddress()`
 * @return {string}
 */
proto.eth.AccessTuple.prototype.getAddress_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getAddress()));
};


/**
 * optional bytes address = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getAddress()`
 * @return {!Uint8Array}
 */
proto.eth.AccessTuple.prototype.getAddress_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getAddress()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.eth.AccessTuple} returns this
 */
proto.eth.AccessTuple.prototype.setAddress = function(value) {
  return jspb.Message.setProto3BytesField(this, 1, value);
};


/**
 * repeated bytes storage_keys = 2;
 * @return {!Array<string>}
 */
proto.eth.AccessTuple.prototype.getStorageKeysList = function() {
  return /** @type {!Array<string>} */ (jspb.Message.getRepeatedField(this, 2));
};


/**
 * repeated bytes storage_keys = 2;
 * This is a type-conversion wrapper around `getStorageKeysList()`
 * @return {!Array<string>}
 */
proto.eth.AccessTuple.prototype.getStorageKeysList_asB64 = function() {
  return /** @type {!Array<string>} */ (jspb.Message.bytesListAsB64(
      this.getStorageKeysList()));
};


/**
 * repeated bytes storage_keys = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getStorageKeysList()`
 * @return {!Array<!Uint8Array>}
 */
proto.eth.AccessTuple.prototype.getStorageKeysList_asU8 = function() {
  return /** @type {!Array<!Uint8Array>} */ (jspb.Message.bytesListAsU8(
      this.getStorageKeysList()));
};


/**
 * @param {!(Array<!Uint8Array>|Array<string>)} value
 * @return {!proto.eth.AccessTuple} returns this
 */
proto.eth.AccessTuple.prototype.setStorageKeysList = function(value) {
  return jspb.Message.setField(this, 2, value || []);
};


/**
 * @param {!(string|Uint8Array)} value
 * @param {number=} opt_index
 * @return {!proto.eth.AccessTuple} returns this
 */
proto.eth.AccessTuple.prototype.addStorageKeys = function(value, opt_index) {
  return jspb.Message.addToRepeatedField(this, 2, value, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.eth.AccessTuple} returns this
 */
proto.eth.AccessTuple.prototype.clearStorageKeysList = function() {
  return this.setStorageKeysList([]);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.eth.StoredTransaction.prototype.toObject = function(opt_includeInstance) {
  return proto.eth.StoredTransaction.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.eth.StoredTransaction} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.eth.StoredTransaction.toObject = function(includeInstance, msg) {
  var f, obj = {
    canonicalData: (f = msg.getCanonicalData()) && proto.eth.CanonicalTransactionData.toObject(includeInstance, f),
    transaction: (f = msg.getTransaction()) && proto.eth.Transaction.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.eth.StoredTransaction}
 */
proto.eth.StoredTransaction.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.eth.StoredTransaction;
  return proto.eth.StoredTransaction.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.eth.StoredTransaction} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.eth.StoredTransaction}
 */
proto.eth.StoredTransaction.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.eth.CanonicalTransactionData;
      reader.readMessage(value,proto.eth.CanonicalTransactionData.deserializeBinaryFromReader);
      msg.setCanonicalData(value);
      break;
    case 2:
      var value = new proto.eth.Transaction;
      reader.readMessage(value,proto.eth.Transaction.deserializeBinaryFromReader);
      msg.setTransaction(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.eth.StoredTransaction.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.eth.StoredTransaction.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.eth.StoredTransaction} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.eth.StoredTransaction.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getCanonicalData();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.eth.CanonicalTransactionData.serializeBinaryToWriter
    );
  }
  f = message.getTransaction();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.eth.Transaction.serializeBinaryToWriter
    );
  }
};


/**
 * optional CanonicalTransactionData canonical_data = 1;
 * @return {?proto.eth.CanonicalTransactionData}
 */
proto.eth.StoredTransaction.prototype.getCanonicalData = function() {
  return /** @type{?proto.eth.CanonicalTransactionData} */ (
    jspb.Message.getWrapperField(this, proto.eth.CanonicalTransactionData, 1));
};


/**
 * @param {?proto.eth.CanonicalTransactionData|undefined} value
 * @return {!proto.eth.StoredTransaction} returns this
*/
proto.eth.StoredTransaction.prototype.setCanonicalData = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.eth.StoredTransaction} returns this
 */
proto.eth.StoredTransaction.prototype.clearCanonicalData = function() {
  return this.setCanonicalData(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.eth.StoredTransaction.prototype.hasCanonicalData = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional Transaction transaction = 2;
 * @return {?proto.eth.Transaction}
 */
proto.eth.StoredTransaction.prototype.getTransaction = function() {
  return /** @type{?proto.eth.Transaction} */ (
    jspb.Message.getWrapperField(this, proto.eth.Transaction, 2));
};


/**
 * @param {?proto.eth.Transaction|undefined} value
 * @return {!proto.eth.StoredTransaction} returns this
*/
proto.eth.StoredTransaction.prototype.setTransaction = function(value) {
  return jspb.Message.setWrapperField(this, 2, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.eth.StoredTransaction} returns this
 */
proto.eth.StoredTransaction.prototype.clearTransaction = function() {
  return this.setTransaction(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.eth.StoredTransaction.prototype.hasTransaction = function() {
  return jspb.Message.getField(this, 2) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.eth.Header.prototype.toObject = function(opt_includeInstance) {
  return proto.eth.Header.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.eth.Header} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.eth.Header.toObject = function(includeInstance, msg) {
  var f, obj = {
    number: jspb.Message.getFieldWithDefault(msg, 1, 0),
    hash: msg.getHash_asB64(),
    parentHash: msg.getParentHash_asB64(),
    nonce: jspb.Message.getFieldWithDefault(msg, 4, 0),
    uncleHash: msg.getUncleHash_asB64(),
    stateRoot: msg.getStateRoot_asB64(),
    receiptRoot: msg.getReceiptRoot_asB64(),
    coinbase: msg.getCoinbase_asB64(),
    difficulty: jspb.Message.getFieldWithDefault(msg, 9, 0),
    totalDifficulty: jspb.Message.getFieldWithDefault(msg, 10, 0),
    extraData: msg.getExtraData_asB64(),
    size: jspb.Message.getFieldWithDefault(msg, 12, 0),
    gasLimit: jspb.Message.getFieldWithDefault(msg, 13, 0),
    gasUsed: jspb.Message.getFieldWithDefault(msg, 14, 0),
    timestamp: jspb.Message.getFieldWithDefault(msg, 15, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.eth.Header}
 */
proto.eth.Header.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.eth.Header;
  return proto.eth.Header.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.eth.Header} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.eth.Header}
 */
proto.eth.Header.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setNumber(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setHash(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setParentHash(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setNonce(value);
      break;
    case 5:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setUncleHash(value);
      break;
    case 6:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setStateRoot(value);
      break;
    case 7:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setReceiptRoot(value);
      break;
    case 8:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setCoinbase(value);
      break;
    case 9:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setDifficulty(value);
      break;
    case 10:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setTotalDifficulty(value);
      break;
    case 11:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setExtraData(value);
      break;
    case 12:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setSize(value);
      break;
    case 13:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setGasLimit(value);
      break;
    case 14:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setGasUsed(value);
      break;
    case 15:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setTimestamp(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.eth.Header.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.eth.Header.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.eth.Header} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.eth.Header.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getNumber();
  if (f !== 0) {
    writer.writeUint64(
      1,
      f
    );
  }
  f = message.getHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = message.getParentHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
  f = message.getNonce();
  if (f !== 0) {
    writer.writeUint64(
      4,
      f
    );
  }
  f = message.getUncleHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      5,
      f
    );
  }
  f = message.getStateRoot_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      6,
      f
    );
  }
  f = message.getReceiptRoot_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      7,
      f
    );
  }
  f = message.getCoinbase_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      8,
      f
    );
  }
  f = message.getDifficulty();
  if (f !== 0) {
    writer.writeUint64(
      9,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 10));
  if (f != null) {
    writer.writeUint64(
      10,
      f
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 11));
  if (f != null) {
    writer.writeBytes(
      11,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 12));
  if (f != null) {
    writer.writeUint64(
      12,
      f
    );
  }
  f = message.getGasLimit();
  if (f !== 0) {
    writer.writeUint64(
      13,
      f
    );
  }
  f = message.getGasUsed();
  if (f !== 0) {
    writer.writeUint64(
      14,
      f
    );
  }
  f = message.getTimestamp();
  if (f !== 0) {
    writer.writeUint64(
      15,
      f
    );
  }
};


/**
 * optional uint64 number = 1;
 * @return {number}
 */
proto.eth.Header.prototype.getNumber = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {number} value
 * @return {!proto.eth.Header} returns this
 */
proto.eth.Header.prototype.setNumber = function(value) {
  return jspb.Message.setProto3IntField(this, 1, value);
};


/**
 * optional bytes hash = 2;
 * @return {string}
 */
proto.eth.Header.prototype.getHash = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes hash = 2;
 * This is a type-conversion wrapper around `getHash()`
 * @return {string}
 */
proto.eth.Header.prototype.getHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getHash()));
};


/**
 * optional bytes hash = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getHash()`
 * @return {!Uint8Array}
 */
proto.eth.Header.prototype.getHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getHash()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.eth.Header} returns this
 */
proto.eth.Header.prototype.setHash = function(value) {
  return jspb.Message.setProto3BytesField(this, 2, value);
};


/**
 * optional bytes parent_hash = 3;
 * @return {string}
 */
proto.eth.Header.prototype.getParentHash = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes parent_hash = 3;
 * This is a type-conversion wrapper around `getParentHash()`
 * @return {string}
 */
proto.eth.Header.prototype.getParentHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getParentHash()));
};


/**
 * optional bytes parent_hash = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getParentHash()`
 * @return {!Uint8Array}
 */
proto.eth.Header.prototype.getParentHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getParentHash()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.eth.Header} returns this
 */
proto.eth.Header.prototype.setParentHash = function(value) {
  return jspb.Message.setProto3BytesField(this, 3, value);
};


/**
 * optional uint64 nonce = 4;
 * @return {number}
 */
proto.eth.Header.prototype.getNonce = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/**
 * @param {number} value
 * @return {!proto.eth.Header} returns this
 */
proto.eth.Header.prototype.setNonce = function(value) {
  return jspb.Message.setProto3IntField(this, 4, value);
};


/**
 * optional bytes uncle_hash = 5;
 * @return {string}
 */
proto.eth.Header.prototype.getUncleHash = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 5, ""));
};


/**
 * optional bytes uncle_hash = 5;
 * This is a type-conversion wrapper around `getUncleHash()`
 * @return {string}
 */
proto.eth.Header.prototype.getUncleHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getUncleHash()));
};


/**
 * optional bytes uncle_hash = 5;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getUncleHash()`
 * @return {!Uint8Array}
 */
proto.eth.Header.prototype.getUncleHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getUncleHash()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.eth.Header} returns this
 */
proto.eth.Header.prototype.setUncleHash = function(value) {
  return jspb.Message.setProto3BytesField(this, 5, value);
};


/**
 * optional bytes state_root = 6;
 * @return {string}
 */
proto.eth.Header.prototype.getStateRoot = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 6, ""));
};


/**
 * optional bytes state_root = 6;
 * This is a type-conversion wrapper around `getStateRoot()`
 * @return {string}
 */
proto.eth.Header.prototype.getStateRoot_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getStateRoot()));
};


/**
 * optional bytes state_root = 6;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getStateRoot()`
 * @return {!Uint8Array}
 */
proto.eth.Header.prototype.getStateRoot_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getStateRoot()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.eth.Header} returns this
 */
proto.eth.Header.prototype.setStateRoot = function(value) {
  return jspb.Message.setProto3BytesField(this, 6, value);
};


/**
 * optional bytes receipt_root = 7;
 * @return {string}
 */
proto.eth.Header.prototype.getReceiptRoot = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 7, ""));
};


/**
 * optional bytes receipt_root = 7;
 * This is a type-conversion wrapper around `getReceiptRoot()`
 * @return {string}
 */
proto.eth.Header.prototype.getReceiptRoot_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getReceiptRoot()));
};


/**
 * optional bytes receipt_root = 7;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getReceiptRoot()`
 * @return {!Uint8Array}
 */
proto.eth.Header.prototype.getReceiptRoot_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getReceiptRoot()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.eth.Header} returns this
 */
proto.eth.Header.prototype.setReceiptRoot = function(value) {
  return jspb.Message.setProto3BytesField(this, 7, value);
};


/**
 * optional bytes coinbase = 8;
 * @return {string}
 */
proto.eth.Header.prototype.getCoinbase = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 8, ""));
};


/**
 * optional bytes coinbase = 8;
 * This is a type-conversion wrapper around `getCoinbase()`
 * @return {string}
 */
proto.eth.Header.prototype.getCoinbase_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getCoinbase()));
};


/**
 * optional bytes coinbase = 8;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getCoinbase()`
 * @return {!Uint8Array}
 */
proto.eth.Header.prototype.getCoinbase_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getCoinbase()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.eth.Header} returns this
 */
proto.eth.Header.prototype.setCoinbase = function(value) {
  return jspb.Message.setProto3BytesField(this, 8, value);
};


/**
 * optional uint64 difficulty = 9;
 * @return {number}
 */
proto.eth.Header.prototype.getDifficulty = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 9, 0));
};


/**
 * @param {number} value
 * @return {!proto.eth.Header} returns this
 */
proto.eth.Header.prototype.setDifficulty = function(value) {
  return jspb.Message.setProto3IntField(this, 9, value);
};


/**
 * optional uint64 total_difficulty = 10;
 * @return {number}
 */
proto.eth.Header.prototype.getTotalDifficulty = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 10, 0));
};


/**
 * @param {number} value
 * @return {!proto.eth.Header} returns this
 */
proto.eth.Header.prototype.setTotalDifficulty = function(value) {
  return jspb.Message.setField(this, 10, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.eth.Header} returns this
 */
proto.eth.Header.prototype.clearTotalDifficulty = function() {
  return jspb.Message.setField(this, 10, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.eth.Header.prototype.hasTotalDifficulty = function() {
  return jspb.Message.getField(this, 10) != null;
};


/**
 * optional bytes extra_data = 11;
 * @return {string}
 */
proto.eth.Header.prototype.getExtraData = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 11, ""));
};


/**
 * optional bytes extra_data = 11;
 * This is a type-conversion wrapper around `getExtraData()`
 * @return {string}
 */
proto.eth.Header.prototype.getExtraData_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getExtraData()));
};


/**
 * optional bytes extra_data = 11;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getExtraData()`
 * @return {!Uint8Array}
 */
proto.eth.Header.prototype.getExtraData_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getExtraData()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.eth.Header} returns this
 */
proto.eth.Header.prototype.setExtraData = function(value) {
  return jspb.Message.setField(this, 11, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.eth.Header} returns this
 */
proto.eth.Header.prototype.clearExtraData = function() {
  return jspb.Message.setField(this, 11, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.eth.Header.prototype.hasExtraData = function() {
  return jspb.Message.getField(this, 11) != null;
};


/**
 * optional uint64 size = 12;
 * @return {number}
 */
proto.eth.Header.prototype.getSize = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 12, 0));
};


/**
 * @param {number} value
 * @return {!proto.eth.Header} returns this
 */
proto.eth.Header.prototype.setSize = function(value) {
  return jspb.Message.setField(this, 12, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.eth.Header} returns this
 */
proto.eth.Header.prototype.clearSize = function() {
  return jspb.Message.setField(this, 12, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.eth.Header.prototype.hasSize = function() {
  return jspb.Message.getField(this, 12) != null;
};


/**
 * optional uint64 gas_limit = 13;
 * @return {number}
 */
proto.eth.Header.prototype.getGasLimit = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 13, 0));
};


/**
 * @param {number} value
 * @return {!proto.eth.Header} returns this
 */
proto.eth.Header.prototype.setGasLimit = function(value) {
  return jspb.Message.setProto3IntField(this, 13, value);
};


/**
 * optional uint64 gas_used = 14;
 * @return {number}
 */
proto.eth.Header.prototype.getGasUsed = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 14, 0));
};


/**
 * @param {number} value
 * @return {!proto.eth.Header} returns this
 */
proto.eth.Header.prototype.setGasUsed = function(value) {
  return jspb.Message.setProto3IntField(this, 14, value);
};


/**
 * optional uint64 timestamp = 15;
 * @return {number}
 */
proto.eth.Header.prototype.getTimestamp = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 15, 0));
};


/**
 * @param {number} value
 * @return {!proto.eth.Header} returns this
 */
proto.eth.Header.prototype.setTimestamp = function(value) {
  return jspb.Message.setProto3IntField(this, 15, value);
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.eth.Body.repeatedFields_ = [1,2];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.eth.Body.prototype.toObject = function(opt_includeInstance) {
  return proto.eth.Body.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.eth.Body} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.eth.Body.toObject = function(includeInstance, msg) {
  var f, obj = {
    transactionsList: jspb.Message.toObjectList(msg.getTransactionsList(),
    proto.eth.Transaction.toObject, includeInstance),
    ommersList: msg.getOmmersList_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.eth.Body}
 */
proto.eth.Body.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.eth.Body;
  return proto.eth.Body.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.eth.Body} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.eth.Body}
 */
proto.eth.Body.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.eth.Transaction;
      reader.readMessage(value,proto.eth.Transaction.deserializeBinaryFromReader);
      msg.addTransactions(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.addOmmers(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.eth.Body.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.eth.Body.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.eth.Body} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.eth.Body.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getTransactionsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      proto.eth.Transaction.serializeBinaryToWriter
    );
  }
  f = message.getOmmersList_asU8();
  if (f.length > 0) {
    writer.writeRepeatedBytes(
      2,
      f
    );
  }
};


/**
 * repeated Transaction transactions = 1;
 * @return {!Array<!proto.eth.Transaction>}
 */
proto.eth.Body.prototype.getTransactionsList = function() {
  return /** @type{!Array<!proto.eth.Transaction>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.eth.Transaction, 1));
};


/**
 * @param {!Array<!proto.eth.Transaction>} value
 * @return {!proto.eth.Body} returns this
*/
proto.eth.Body.prototype.setTransactionsList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.eth.Transaction=} opt_value
 * @param {number=} opt_index
 * @return {!proto.eth.Transaction}
 */
proto.eth.Body.prototype.addTransactions = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.eth.Transaction, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.eth.Body} returns this
 */
proto.eth.Body.prototype.clearTransactionsList = function() {
  return this.setTransactionsList([]);
};


/**
 * repeated bytes ommers = 2;
 * @return {!Array<string>}
 */
proto.eth.Body.prototype.getOmmersList = function() {
  return /** @type {!Array<string>} */ (jspb.Message.getRepeatedField(this, 2));
};


/**
 * repeated bytes ommers = 2;
 * This is a type-conversion wrapper around `getOmmersList()`
 * @return {!Array<string>}
 */
proto.eth.Body.prototype.getOmmersList_asB64 = function() {
  return /** @type {!Array<string>} */ (jspb.Message.bytesListAsB64(
      this.getOmmersList()));
};


/**
 * repeated bytes ommers = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getOmmersList()`
 * @return {!Array<!Uint8Array>}
 */
proto.eth.Body.prototype.getOmmersList_asU8 = function() {
  return /** @type {!Array<!Uint8Array>} */ (jspb.Message.bytesListAsU8(
      this.getOmmersList()));
};


/**
 * @param {!(Array<!Uint8Array>|Array<string>)} value
 * @return {!proto.eth.Body} returns this
 */
proto.eth.Body.prototype.setOmmersList = function(value) {
  return jspb.Message.setField(this, 2, value || []);
};


/**
 * @param {!(string|Uint8Array)} value
 * @param {number=} opt_index
 * @return {!proto.eth.Body} returns this
 */
proto.eth.Body.prototype.addOmmers = function(value, opt_index) {
  return jspb.Message.addToRepeatedField(this, 2, value, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.eth.Body} returns this
 */
proto.eth.Body.prototype.clearOmmersList = function() {
  return this.setOmmersList([]);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.eth.Block.prototype.toObject = function(opt_includeInstance) {
  return proto.eth.Block.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.eth.Block} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.eth.Block.toObject = function(includeInstance, msg) {
  var f, obj = {
    header: (f = msg.getHeader()) && proto.eth.Header.toObject(includeInstance, f),
    body: (f = msg.getBody()) && proto.eth.Body.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.eth.Block}
 */
proto.eth.Block.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.eth.Block;
  return proto.eth.Block.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.eth.Block} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.eth.Block}
 */
proto.eth.Block.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.eth.Header;
      reader.readMessage(value,proto.eth.Header.deserializeBinaryFromReader);
      msg.setHeader(value);
      break;
    case 2:
      var value = new proto.eth.Body;
      reader.readMessage(value,proto.eth.Body.deserializeBinaryFromReader);
      msg.setBody(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.eth.Block.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.eth.Block.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.eth.Block} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.eth.Block.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getHeader();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.eth.Header.serializeBinaryToWriter
    );
  }
  f = message.getBody();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.eth.Body.serializeBinaryToWriter
    );
  }
};


/**
 * optional Header header = 1;
 * @return {?proto.eth.Header}
 */
proto.eth.Block.prototype.getHeader = function() {
  return /** @type{?proto.eth.Header} */ (
    jspb.Message.getWrapperField(this, proto.eth.Header, 1));
};


/**
 * @param {?proto.eth.Header|undefined} value
 * @return {!proto.eth.Block} returns this
*/
proto.eth.Block.prototype.setHeader = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.eth.Block} returns this
 */
proto.eth.Block.prototype.clearHeader = function() {
  return this.setHeader(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.eth.Block.prototype.hasHeader = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional Body body = 2;
 * @return {?proto.eth.Body}
 */
proto.eth.Block.prototype.getBody = function() {
  return /** @type{?proto.eth.Body} */ (
    jspb.Message.getWrapperField(this, proto.eth.Body, 2));
};


/**
 * @param {?proto.eth.Body|undefined} value
 * @return {!proto.eth.Block} returns this
*/
proto.eth.Block.prototype.setBody = function(value) {
  return jspb.Message.setWrapperField(this, 2, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.eth.Block} returns this
 */
proto.eth.Block.prototype.clearBody = function() {
  return this.setBody(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.eth.Block.prototype.hasBody = function() {
  return jspb.Message.getField(this, 2) != null;
};


goog.object.extend(exports, proto.eth);
